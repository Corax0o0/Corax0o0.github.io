<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>[第二章]  壹 | Corax</title>
<link rel="shortcut icon" href="https://Corax0o0.github.io/favicon.ico?v=1670214330875">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://Corax0o0.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="[第二章]  壹 | Corax - Atom Feed" href="https://Corax0o0.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="2.1OllyDbg调试器
OllyDbg界面

C窗口是最重要的窗口，绝大部分都要在这个窗口进行，有五个面板窗口，分别是反汇编面板，寄存器面板，信息面板，数据面板和栈面板。
1.反汇编面板窗口

从左到右分别是地址，十六进制的机器码，反汇..." />
    <meta name="keywords" content="随记【加密与解密】" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Corax0o0.github.io">
  <img class="avatar" src="https://Corax0o0.github.io/images/avatar.png?v=1670214330875" alt="">
  </a>
  <h1 class="site-title">
    Corax
  </h1>
  <p class="site-description">
    成为想成为的
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://Corax0o0.github.io/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              [第二章]  壹
            </h2>
            <div class="post-info">
              <span>
                2022-11-28
              </span>
              <span>
                8 min read
              </span>
              
                <a href="https://Corax0o0.github.io/tag/wrRrQmAYX/" class="post-tag">
                  # 随记【加密与解密】
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://Corax0o0.github.io/post-images/di-er-zhang-yi.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="21ollydbg调试器">2.1OllyDbg调试器</h1>
<h2 id="ollydbg界面">OllyDbg界面</h2>
<p><img src="https://Corax0o0.github.io/post-images/1669650892170.png" alt="" loading="lazy"><br>
C窗口是最重要的窗口，绝大部分都要在这个窗口进行，有五个面板窗口，分别是反汇编面板，寄存器面板，信息面板，数据面板和栈面板。</p>
<h3 id="1反汇编面板窗口">1.反汇编面板窗口</h3>
<p><img src="https://Corax0o0.github.io/post-images/1669651289012.png" alt="" loading="lazy"><br>
从左到右分别是地址，十六进制的机器码，反汇编代码和注释。</p>
<h3 id="2信息面板窗口">2.信息面板窗口</h3>
<p><img src="https://Corax0o0.github.io/post-images/1669651454836.png" alt="" loading="lazy"><br>
在进行动态分析时，这个面板会显示各种寄存器的值，API函数调用提示和跳转信息。</p>
<h3 id="3数据面板窗口">3.数据面板窗口</h3>
<p><img src="https://Corax0o0.github.io/post-images/1669651569386.png" alt="" loading="lazy"><br>
以十六进制和字符方式显示文件存放内存中的数据。</p>
<h3 id="4寄存器面板窗口">4.寄存器面板窗口</h3>
<p><img src="https://Corax0o0.github.io/post-images/1669651712253.png" alt="" loading="lazy"><br>
显示各种寄存器的值。</p>
<h3 id="5栈面板窗口">5.栈面板窗口</h3>
<p><img src="https://Corax0o0.github.io/post-images/1669651755011.png" alt="" loading="lazy"><br>
显示栈的内容，即ESP指向的内容。</p>
<h2 id="ollydbg的配置">OllyDbg的配置</h2>
<h3 id="1界面设置">1.界面设置</h3>
<p>可以设置UDD文件和插件的路径，并且设置外观。<br>
UDD文件是OllyDbg的工程文件，用于保存当前调试的一些状态，以便于下次调试使用。插件用于扩充功能。</p>
<h3 id="2调试设置">2.调试设置</h3>
<p>可以使OllyDbg忽略或者不忽略某些异常，可以全部选择。</p>
<h3 id="3加载符号文件">3.加载符号文件</h3>
<p>它使用符号库让OllyDbg以函数名的形式显示DLL的函数。例如，MFC42.DLL以序号的形式输出函数，这时在OllyDbg中显示的序号，如果让其加载MFC42.DLL，将以函数名的形式输出它。</p>
<h2 id="基本操作">基本操作</h2>
<h3 id="1准备工作">1.准备工作</h3>
<p>在Windows程序当中需要调用许多的API函数，只要了解哪些API函数被调用，就可以很容易找到一些线索。因此在逆向分析的时候选择以什么API函数为入口就十分重要。</p>
<h3 id="2加载目标文件进行调试">2.加载目标文件进行调试</h3>
<p>为了使ollydbg可以中断在程序的入口处，加载程序前要做相应的设置。比如在WinMain地方中断，模块的加载与卸载，线程的操作等等。<br>
有些程序会使用特别的修改方式使调试的时候不停在入口，以达到反调试的目的。</p>
<h3 id="3单步追踪">3.单步追踪</h3>
<p>调试器最基本的一个功能就是动态跟踪。<br>
<img src="https://Corax0o0.github.io/post-images/1669806641315.png" alt="" loading="lazy"><br>
需要注意好单步步进和单步步过的区别：步进进入call，步过不进入call。</p>
<h3 id="4设置断点">4.设置断点</h3>
<p>这是调试器的一个相当重要的功能，可以让程序中断在指定的地方，从而进行分析。按F2将光标处设置一个断点，再次点击就可以取消断点。<br>
设置断点后按Alt＋B的快捷键，打开断点窗口，可以看到断点的明细。”Always“断点处于激活状态，”Disable“表示断点停用。<br>
<img src="https://Corax0o0.github.io/post-images/1669807064472.png" alt="" loading="lazy"></p>
<h3 id="5调试分析">5.调试分析</h3>
<p>可以通过不停地下一步“F8”，然后看数据和栈库里面的信息调试，进行分析。</p>
<h3 id="6爆破法">6.爆破法</h3>
<p>通过序列号的判断核心。例如如下的这个过程。<br>
<img src="https://Corax0o0.github.io/post-images/1669807671073.png" alt="" loading="lazy"><br>
跳过这个判断的过程，通过以下的方式就可以跳过。<br>
<img src="https://Corax0o0.github.io/post-images/1669808237178.png" alt="" loading="lazy"><br>
这个方法成为爆破法。</p>
<h3 id="7算法分析">7.算法分析</h3>
<p>这个方法是推荐我们在程序的过程当中把算法给分析明白。知道汇编代码调用了什么函数就可以进入它，通过观察栈的情况来一步一步监视数据的变化，可以找到需要的数据了。</p>
<h2 id="常用断点">常用断点</h2>
<h3 id="1int3断点">1.INT3断点</h3>
<p>这是一个十分常用的断点，原理是通过将光标所指向的内容用调试器替换成INT3指令，使之可以中断在那个地方。（但在Ollydbg里面看的时候该是什么指令还是什么指令）<br>
<img src="https://Corax0o0.github.io/post-images/1669898334724.png" alt="" loading="lazy"><br>
INT3指令因为他的机器码也是CC，所以也被称为CC代码。当调试到执行INT3指令的时候会跳出一个异常，这个异常是程序中断在断点处，之后将该处的指令从INT3变回原来的指令。<br>
可以设置无数个INT3断点，缺点就是改变了机器码，很容易被程序检测到。例如有些程序会检测API的首地址是不是0xCC来防止API被下断。<br>
<strong>躲过检测的方法就是将断点设置在函数内部或者末尾，例如将断点设置在函数入口的下一行。</strong></p>
<h3 id="2硬件断点">2.硬件断点</h3>
<p>硬件断点和DRx调试寄存器有关。<br>
<img src="https://Corax0o0.github.io/post-images/1669899051012.png" alt="" loading="lazy"><br>
DRx调试寄存器共8个。<br>
<strong>DR0~DR3调试地址寄存器来保存需要监视的地址。</strong><br>
DR4~DR5保留，未公开。<br>
DR6调试寄存器组状态寄存器。<br>
DR7调试寄存器组控制寄存器。<br>
硬件断点原理就是使用DR0123设置地址并使用DR7设定状态，最多设置4个断点。硬件执行断点和CC断点一致，但不会改变机器码所以更难检测。设置方法是在指定的代码行右键，在Breakpoint中Hardware，on execution命令。假使我们在4013AAh位置设置一个硬件断点，那么Ollydbg就会让DR0~DR3中一个设置为004013AA，然后在DR7中设置相应的控制位。当调试进程到004013AAh的地方CPU就会向Ollydbg发出异常信息，中断。<br>
硬件断点优点就是速度快，不容易被程序发现，缺点是只能设置4个断点。</p>
<h3 id="3内存断点">3.内存断点</h3>
<p>原理是对所设的地址赋予不可访问/不可写属性，这样当访问/写入的时候就会产生异常。OllyDbg会截获异常然后比较这个地址是不是断点地址，如果是就中断，让用户继续操作。因此每次异常都需要比较是否应该中断，这样就会导致运行速度变慢。OllyDbg也只能设定一个内存断点。<br>
需要注意的是，硬件访问/写入断点是在出发硬件断点的下一条指令下断，内存断点是在触发断点的指令处下断。<br>
这个方法也不用修改原始代码，不会像INT3那样被检测。</p>
<h3 id="4内存访问一次性断点">4.内存访问一次性断点</h3>
<p>这个方法是对一个段进行设置一个一次性断点，当所在段被读取他就会中断。如果想捕捉调用或返回某个模块时候，这个断点就非常有用。进行一次中断后，断点就会被删除。</p>
<h3 id="5消息断点"><strong>5.消息断点</strong></h3>
<p>Windows是由消息驱动的，如果调试没有合适的断点就可以使用消息断点。当某个特定窗口接收到某个特定消息后，消息断点就会使程序中断。INT3断点在程序启动前设置，消息断点只有在窗口被创建的时候才能设置并拦截消息。<br>
当用户单击一个按钮，移动光标或者向文本框输入文字的时候，一条消息就会发送给当前窗体。所有发送的消息都有4个参数。分别涉及一个窗口句柄（hwnd），一个消息编号（msg）和2个32位长的参数。Windows通过句柄来识别它所代表的对象。例如，在单击某个按钮的时候，Windows通过句柄来判断单机了哪一个按钮，然后发送相应的消息来通知程序。<br>
例如下面的TraceMe，运行后这个窗口列出了所有属于被调试程序窗口及窗口相关的重要参数，例如按钮，相应的ID以及句柄。我们现在要对Check按钮下断点，即单击该按钮的时候程序中断。在check条目上单击右键。<br>
<img src="https://Corax0o0.github.io/post-images/1670213579245.png" alt="" loading="lazy"><br>
回到TraceMe界面，单击check按钮，松开鼠标时，程序就会中断在Windows<strong>系统代码</strong>中，代码如下。<br>
<img src="https://Corax0o0.github.io/post-images/1670213993832.png" alt="" loading="lazy"><br>
消息已经捕捉到，但仍然处于系统底层代码当中，不属于TraceMe主程序的代码，这是企图用alt+f9来返回程序代码领空是不行的。<br>
主程序在00401000h开头的.text区块里。从系统代码回到程序代码段的时候就是.text区块代码执行的时候，因此对.texr也下一个内存断点就可以返回应用程序的代码领空。<br>
<img src="https://Corax0o0.github.io/post-images/1670214193838.png" alt="" loading="lazy"><br>
这段代码是一个消息循环，不停处理TraceMe主界面各种消息，此时可能不会直接处理按钮事件。如果单步追踪，就会进入系统代码。在系统代码里，按Alt+m快捷键打开内存窗口，对.text区块进行内存访问的点点，在按f9执行内存断点就可以返回代码段，重复这个过程就可以达到处理按钮的效果了。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#21ollydbg%E8%B0%83%E8%AF%95%E5%99%A8">2.1OllyDbg调试器</a>
<ul>
<li><a href="#ollydbg%E7%95%8C%E9%9D%A2">OllyDbg界面</a>
<ul>
<li><a href="#1%E5%8F%8D%E6%B1%87%E7%BC%96%E9%9D%A2%E6%9D%BF%E7%AA%97%E5%8F%A3">1.反汇编面板窗口</a></li>
<li><a href="#2%E4%BF%A1%E6%81%AF%E9%9D%A2%E6%9D%BF%E7%AA%97%E5%8F%A3">2.信息面板窗口</a></li>
<li><a href="#3%E6%95%B0%E6%8D%AE%E9%9D%A2%E6%9D%BF%E7%AA%97%E5%8F%A3">3.数据面板窗口</a></li>
<li><a href="#4%E5%AF%84%E5%AD%98%E5%99%A8%E9%9D%A2%E6%9D%BF%E7%AA%97%E5%8F%A3">4.寄存器面板窗口</a></li>
<li><a href="#5%E6%A0%88%E9%9D%A2%E6%9D%BF%E7%AA%97%E5%8F%A3">5.栈面板窗口</a></li>
</ul>
</li>
<li><a href="#ollydbg%E7%9A%84%E9%85%8D%E7%BD%AE">OllyDbg的配置</a>
<ul>
<li><a href="#1%E7%95%8C%E9%9D%A2%E8%AE%BE%E7%BD%AE">1.界面设置</a></li>
<li><a href="#2%E8%B0%83%E8%AF%95%E8%AE%BE%E7%BD%AE">2.调试设置</a></li>
<li><a href="#3%E5%8A%A0%E8%BD%BD%E7%AC%A6%E5%8F%B7%E6%96%87%E4%BB%B6">3.加载符号文件</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">基本操作</a>
<ul>
<li><a href="#1%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">1.准备工作</a></li>
<li><a href="#2%E5%8A%A0%E8%BD%BD%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95">2.加载目标文件进行调试</a></li>
<li><a href="#3%E5%8D%95%E6%AD%A5%E8%BF%BD%E8%B8%AA">3.单步追踪</a></li>
<li><a href="#4%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9">4.设置断点</a></li>
<li><a href="#5%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90">5.调试分析</a></li>
<li><a href="#6%E7%88%86%E7%A0%B4%E6%B3%95">6.爆破法</a></li>
<li><a href="#7%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90">7.算法分析</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%96%AD%E7%82%B9">常用断点</a>
<ul>
<li><a href="#1int3%E6%96%AD%E7%82%B9">1.INT3断点</a></li>
<li><a href="#2%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9">2.硬件断点</a></li>
<li><a href="#3%E5%86%85%E5%AD%98%E6%96%AD%E7%82%B9">3.内存断点</a></li>
<li><a href="#4%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E4%B8%80%E6%AC%A1%E6%80%A7%E6%96%AD%E7%82%B9">4.内存访问一次性断点</a></li>
<li><a href="#5%E6%B6%88%E6%81%AF%E6%96%AD%E7%82%B9"><strong>5.消息断点</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Corax0o0.github.io/post/ni-hao/">
              <h3 class="post-title">
                你好
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://Corax0o0.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
